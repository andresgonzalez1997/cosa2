import fitz      # pip install pymupdf
import datetime
import re
import pandas as pd
import sys

# --------------------------------------------------------------------------------
# 0) Esquema de columnas y tipos
# --------------------------------------------------------------------------------
SCHEMA = {
    "product_number": "string",
    "formula_code": "string",
    "product_name": "string",
    "product_form": "string",
    "unit_weight": "double",
    "pallet_quantity": "double",
    "stocking_status": "string",
    "min_order_quantity": "double",
    "days_lead_time": "double",
    "fob_or_dlv": "string",
    "price_change": "double",
    "list_price": "double",
    "full_pallet_price": "double",
    "half_load_full_pallet_price": "double",
    "full_load_full_pallet_price": "double",
    "full_load_best_price": "double",
    "plant_location": "string",
    "date_inserted": "string",
    "source": "string"
}
SCHEMA_COLS  = list(SCHEMA.keys())
NUMERIC_COLS = [c for c,t in SCHEMA.items() if t == "double"]

# --------------------------------------------------------------------------------
# 1) Funciones para extraer fecha y ubicación (página 1)
# --------------------------------------------------------------------------------

def effective_date(path):
    try:
        doc  = fitz.open(path)
        page = doc.load_page(0)
        area = fitz.Rect(0, 50, page.rect.width, 130)
        txt  = page.get_text("text", clip=area)
        m = re.search(r"\b\d{1,2}/\d{1,2}/(?:\d{4}|\d{2})\b", txt)
        if not m: return None
        ds = m.group(0)
        for fmt in ("%m/%d/%Y", "%m/%d/%y"):
            try:
                return datetime.datetime.strptime(ds, fmt).date().strftime("%Y-%m-%d")
            except ValueError:
                continue
    except:
        pass
    return None

def plant_location(path):
    try:
        doc  = fitz.open(path)
        page = doc.load_page(0)
        area = fitz.Rect(0, 0, page.rect.width, 50)
        txt  = page.get_text("text", clip=area).upper()
        if "HUDSON'S" in txt:
            return "HUDSON'S"
        first = txt.split("\n")[0].strip()
        return first.replace(",", "").strip()
    except:
        return None

# --------------------------------------------------------------------------------
# 2) Extracción de la “tabla” real
# --------------------------------------------------------------------------------

def extract_main_table(path, header_offset=100):
    """
    - Recorta cada página por debajo de y=header_offset para omitir cabecera.
    - Salta líneas de header hasta encontrarse la primera línea con dígitos.
    - Luego, split por 2+ espacios, normaliza a len(SCHEMA_COLS) columnas.
    - Devuelve [DataFrame].
    """
    rows = []
    data_started = False

    doc = fitz.open(path)
    for page in doc:
        clip = fitz.Rect(0, header_offset, page.rect.width, page.rect.height)
        text = page.get_text("text", clip=clip)
        for line in text.split("\n"):
            line = line.strip()
            if not line:
                continue

            # Si aún no hemos empezado datos, esperar a la 1ª línea con dígitos
            if not data_started:
                if re.search(r"\d", line) and not re.search(
                    r"price in us dollars|product number|formula code|product desc|product form|unit weight|pallet quantity|stocking status",
                    line, re.I):
                    data_started = True
                else:
                    continue

            # A partir de aquí ya es dato: dividimos por 2+ espacios
            cols = re.split(r"\s{2,}", line)
            rows.append(cols)

    if not rows:
        return []

    # Normalizar cada fila al número exacto de columnas del esquema
    n = len(SCHEMA_COLS)
    cleaned = []
    for r in rows:
        if len(r) < n:
            r = r + [""] * (n - len(r))
        elif len(r) > n:
            # Si sobran, concatenar el exceso en la última columna
            r = r[: n - 1] + [" ".join(r[n - 1 :])]
        cleaned.append(r)

    # Construir DataFrame con las columnas del esquema
    df = pd.DataFrame(cleaned, columns=SCHEMA_COLS)
    return [df]

# --------------------------------------------------------------------------------
# 3) Corrección de negativos y parseo de números
# --------------------------------------------------------------------------------

def correct_negative_value(v):
    txt = str(v).strip()
    if txt.endswith("-"):
        try:
            return -float(txt[:-1])
        except:
            return v
    try:
        return float(txt)
    except:
        return v

# --------------------------------------------------------------------------------
# 4) Función principal: unifica todo y da el DF final
# --------------------------------------------------------------------------------

def read_file(path):
    # a) extraer tabla
    tables = extract_main_table(path)
    if not tables:
        # devolvemos un DF vacío con todas las columnas del esquema
        return pd.DataFrame({
            c: pd.Series(dtype="float" if SCHEMA[c]=="double" else "object")
            for c in SCHEMA_COLS
        })

    # b) concatenar
    df = pd.concat(tables, ignore_index=True)

    # c) corregir negativos en columnas numéricas
    for col in NUMERIC_COLS:
        if col in df.columns:
            df[col] = df[col].apply(correct_negative_value)

    # d) asegurar existencia y tipo de todas las columnas
    for col, typ in SCHEMA.items():
        if col not in df.columns:
            df[col] = pd.Series(dtype="float" if typ=="double" else "object")
        else:
            if typ == "double":
                df[col] = pd.to_numeric(df[col], errors="coerce")
            else:
                df[col] = df[col].astype(str)

    # e) metadatos
    df["plant_location"] = plant_location(path) or ""
    df["date_inserted"]  = effective_date(path) or ""
    df["source"]         = "pdf"

    # f) reordenar al esquema y listo
    return df[SCHEMA_COLS]

# --------------------------------------------------------------------------------
# 5) Ejecución desde la consola
# --------------------------------------------------------------------------------

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Uso: python purina_parser.py <ruta_al_pdf>")
        sys.exit(1)

    pdf_path = sys.argv[1]
    df_final = read_file(pdf_path)

    print("\n--- TIPOS DEL DATAFRAME ---")
    print(df_final.dtypes, "\n")
    print("--- INFO DEL DATAFRAME FINAL ---")
    print(df_final.info(), "\n")
    print("--- MUESTRA DE FILAS ---")
    print(df_final.head())
