"""
Lectura y limpieza de PDFs.

• Conservar la primera línea real de datos de cada página.
• Eliminar cabeceras repetidas ("PRODUCT NUMBER …"), fragmentos ("MIN / DAYS")
  y textos sueltos como "Price / Unit" o "Price in US Dollars".
• Corrige números negativos (100-  →  -100) y añade metadatos (fecha, planta, source).
• NEW ▶ Asigna la columna «species» de forma **secuencial**:
         primera tabla → primer nombre del listado, segunda tabla → segundo nombre…
         (no se infiere del PDF).
• Uso público:    >>> df = read_file("2025.03.03 Statesville.pdf")
                  Devuelve un DataFrame con 19 columnas + metadatos + «species».
"""

from __future__ import annotations
import datetime as _dt
import pathlib
import re
from typing import List, Optional, Sequence
from PyPDF2 import PdfReader
import pandas as pd
import tabula

# --------------------------------------------------------------------------- #
# 1. Nombres estándar (16 columnas del PDF original)
# --------------------------------------------------------------------------- #
COLUMN_NAMES: List[str] = [
    "product_number", 
    "formula_code", 
    "product_name", 
    "product_form",
    "unit_weight", 
    "pallet_quantity",
    "stocking_status",
    "min_order_quantity",
    "days_lead_time",
    "fob_or_dlv",
    "price_change",
    "list_price",
    "full_pallet_price",
    "half_load_full_pallet_price",
    "full_load_full_pallet_price",
    "full_load_best_price",
]

# --------------------------------------------------------------------------- #
# 2. Columnas numéricas a convertir a float (evita errores Parquet/Impala)
# --------------------------------------------------------------------------- #
NUMERIC_COLS: List[str] = [
    "pallet_quantity", "min_order_quantity", "days_lead_time",
] + COLUMN_NAMES[10:]

# --------------------------------------------------------------------------- #
# 3. Patrones de fecha + planta
# --------------------------------------------------------------------------- #
_DATE_PATTERNS = [
    re.compile(r'(\d{1,2}[/-]\d{1,2}[/-]\d{2,4})\s*Effective\s+Date', re.I),
    re.compile(r'Effective\s+Date\s*[-–—]?\s*(\d{1,2}[/-]\d{1,2}[/-]\d{2,4})', re.I),
]

# --------------------------------------------------------------------------- #
# 4. Utilidades Tabula
# --------------------------------------------------------------------------- #
def _first_table(pdf: str | pathlib.Path, area) -> str:
    try:
        t = tabula.read_pdf(
            pdf,
            pages=1,
            lattice=True,
            guess=False,
            area=area,
            pandas_options={"header": None, "dtype": str},
        )[0]
        return " ".join(t.astype(str).values.ravel())
    except Exception:
        return ""

# --------------------------------------------------------------------------- #
# 5. FECHA EFECTIVA
# --------------------------------------------------------------------------- #
def extract_effective_date(pdf_path: str | pathlib.Path) -> _dt.date:
    """Devuelve la fecha efectiva como date() – admite '/', '-' y año 2/4 dígitos."""
    reader = PdfReader(str(pdf_path))
    first_page_text = reader.pages[0].extract_text()

    for rx in _DATE_PATTERNS:
        m = rx.search(first_page_text)
        if m:
            date_str = m.group(1)
            sep = "/" if "/" in date_str else "-"
            mm, dd, yy = date_str.split(sep)
            if len(yy) == 2:
                yy = "20" + yy
            return _dt.datetime.strptime(
                f"{mm}{sep}{dd}{sep}{yy}", f"%m{sep}%d{sep}%Y"
            ).date()

    raise ValueError("No se encontró la fecha efectiva en el PDF.")

# --------------------------------------------------------------------------- #
# 6. PLANT LOCATION (horizontal)
# --------------------------------------------------------------------------- #
def extract_plant_location(pdf_path: str | pathlib.Path) -> str:
    """Extrae «STATESVILLE NC», «HUDSON'S NC», etc."""
    try:
        tables = tabula.read_pdf(
            pdf_path,
            pages=1,
            area=[0, 650, 60, 1000],
            lattice=False,
            guess=False,
            pandas_options={"header": None, "dtype": str},
        )
        if not tables:
            return "PLANTA DESCONOCIDA"

        text = " ".join(tables[0].fillna("").values.flatten())
        m = re.search(r"-\s*([A-Za-z &.\-]+?)\s+([A-Za-z]{2})\b", text)
        if m:
            plant, state = m.groups()
            return f"{plant.strip().upper()} {state.upper()}"
        return "PLANTA DESCONOCIDA"

    except Exception:
        return "PLANTA DESCONOCIDA"

# --------------------------------------------------------------------------- #
# 7. Lectura de tablas crudas
# --------------------------------------------------------------------------- #
def _read_tables(pdf: str | pathlib.Path):
    try:
        return tabula.read_pdf(
            pdf,
            pages="all",
            lattice=True,
            guess=False,
            pandas_options={"dtype": str, "header": None},
        )
    except Exception as exc:
        print("[tabula]", exc)
        return []

# --------------------------------------------------------------------------- #
# 8. Estandarización de cada tabla
# --------------------------------------------------------------------------- #
def _standardize(tbl: pd.DataFrame) -> Optional[pd.DataFrame]:
    """Recorta a 16 columnas y corrige tablas desplazadas (17 col.)."""
    if tbl.shape[1] < 16:
        return None

    if tbl.shape[1] >= 17:                               # 17 = categoría + 16 datos
        first, second = tbl.iloc[:, 0], tbl.iloc[:, 1]
        if second.astype(str).str[0].str.isdigit().mean() > 0.5:
            tbl = tbl.iloc[:, 1:17]                       # descarta la categoría
        else:
            tbl = tbl.iloc[:, :16]
    else:
        tbl = tbl.iloc[:, :16]

    tbl.columns = COLUMN_NAMES
    return tbl

# --------------------------------------------------------------------------- #
# 9. Conversión numérica puntual
# --------------------------------------------------------------------------- #
def _to_float(s: str):
    if pd.isna(s):
        return None
    s = str(s).replace(",", "").strip()
    sign = -1 if s.endswith("-") or (s.startswith("(") and s.endswith(")")) else 1
    s = s.strip("()- ")
    try:
        return float(s) * sign
    except ValueError:
        return None

def _fix_numeric(df: pd.DataFrame) -> pd.DataFrame:
    for col in NUMERIC_COLS:
        if col in df.columns:
            df[col] = df[col].apply(_to_float)
    return df

# --------------------------------------------------------------------------- #
# 9-bis. Asignación secuencial de «species»  ← NUEVO
# --------------------------------------------------------------------------- #
SPECIES_SEQUENCE: Sequence[str] = [
    "AQUACULTURE",
    "CATTLE - ACCURATION/SPR BLOCKS",
    "CATTLE - PROTEIN TUBS",
    "CATTLE - MINERAL TUBS",
    "CATTLE - WEATHERIZED MINERAL",
    "CATTLE - STARTERS",
    "CATTLE - FINISHERS",
    "CATTLE - RANGE SUPPLEMENTS",
    "SHEEP",
    "ALL PURPOSE LIVESTOCK",
    "DEER/GAME",
    "FAMILY FLOCK",
    "FAMILY FLOCK ORGANIC",
    "GAME BIRD",
    "GOAT",
    "GRAINLAND",
    "HORSE",
    "TRIPLE CROWN HORSE",
    "MAZURI BIRD/RATITE",
    "MAZURI HERBIVORE",
    "MAZURI KOI / AQUATIC",
    "MAZURI ALPACA/LLAMA",
    "MAZURI MINIPIG",
    "MAZURI OTHER",
    "MAZURI PRIMATE",
    "MAZURI RODENT",
    "MAZURI SMALL PACK",
    "SPECIALTY MILK REPLACERS",
    "MILK REPLACER - FULL POTENTIAL",
    "MILK REPLACER - GROWTH",
    "CALF CARE SUPPLEMENTS",
    "PET FOOD - EXCLUSIVE PRODUCTS",
    "PET FOOD - INFINIA PRODUCTS",
    "PET FOOD - RED FLANNEL",
    "PET FOOD - PMI TRADITIONAL",
    "RABBIT",
    "PREMIUM SHOW DIETS",
    "WILD BIRD",
    "SWINE RETAIL",
    "PLF CATTLE",
]

def _tag_species_by_table(tables: List[pd.DataFrame]) -> List[pd.DataFrame]:
    """Añade la columna species a cada tabla según su posición (0-based)."""
    tagged: List[pd.DataFrame] = []
    for idx, t in enumerate(tables):
        species = SPECIES_SEQUENCE[idx] if idx < len(SPECIES_SEQUENCE) else None
        t = t.copy()
        t["species"] = species
        tagged.append(t)
    return tagged

# --------------------------------------------------------------------------- #
# 10. Función pública
# --------------------------------------------------------------------------- #
def read_file(pdf: str | pathlib.Path) -> pd.DataFrame:
    """
    Procesa un PDF horizontal y devuelve un DataFrame limpio,
    con metadatos y la columna «species» asignada en orden.
    """
    raw_tables    = _read_tables(str(pdf))
    norm_tables   = [t for t in (_standardize(x) for x in raw_tables) if t is not None]
    if not norm_tables:
        return pd.DataFrame()

    # NEW ▶ species inyectada aquí mismo, tabla por tabla
    tagged_tables = _tag_species_by_table(norm_tables)
    df            = pd.concat(tagged_tables, ignore_index=True)

    # Filtro de cabeceras/fragmentos (aprovecha que species ya existe)
    df = df[
        ~df.apply(
            lambda row: _PRICE_RE.search(" ".join(row.astype(str)).upper()) is not None,
            axis=1,
        )
    ].reset_index(drop=True)

    df.dropna(how="all", inplace=True)

    # Metadatos
    df["plant_location"] = extract_plant_location(pdf)
    df["date_inserted"]  = extract_effective_date(pdf)
    df["source"]         = pathlib.Path(pdf).name

    df = _fix_numeric(df)

    # Orden final → 16 originales + metadatos + species
    return df[[*COLUMN_NAMES, "plant_location", "date_inserted", "source", "species"]]
