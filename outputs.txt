#!/usr/bin/env python3
# quick_statesville_multi.py

import sys
import re
import datetime
import pandas as pd
import fitz       # pip install pymupdf
import tabula     # pip install tabula-py

def effective_date(path):
    """Extrae la fecha (mm/dd/yyyy o mm/dd/yy) de y=50..130 pt en la pág.1."""
    try:
        doc  = fitz.open(path)
        page = doc.load_page(0)
        txt  = page.get_text("text", clip=fitz.Rect(0,50,page.rect.width,130))
        m    = re.search(r"\b\d{1,2}/\d{1,2}/(?:\d{2}|\d{4})\b", txt)
        if not m: return ""
        for fmt in ("%m/%d/%Y","%m/%d/%y"):
            try:
                return datetime.datetime.strptime(m.group(0), fmt).date().isoformat()
            except ValueError:
                pass
    except:
        pass
    return ""

def plant_location(path):
    """Extrae HUDSON'S (o primera línea) de y=0..50 pt en la pág.1."""
    try:
        doc  = fitz.open(path)
        page = doc.load_page(0)
        txt  = page.get_text("text", clip=fitz.Rect(0,0,page.rect.width,50)).upper()
        if "HUDSON'S" in txt:
            return "HUDSON'S"
        return txt.split("\n",1)[0].strip().replace(",", "")
    except:
        return ""

def read_file(path):
    """
    1) Lee todas las tablas con Tabula en modo multiple_tables=True
    2) Une en un solo DataFrame
    3) Limpia headers repetidos y filas vacías
    4) Normaliza nombres de columna
    5) Convierte columnas numéricas (incluyendo guion final como negativo)
    6) Agrega metadatos
    """
    # 1) Extrae todas las tablas detectadas
    dfs = tabula.read_pdf(
        path,
        pages="all",
        guess=True,
        multiple_tables=True
    )
    if not dfs:
        raise RuntimeError("Tabula no extrajo ninguna tabla.")

    # 2) Concatena, ignorando índice y ordenando columnas según aparezcan
    df = pd.concat(dfs, ignore_index=True, sort=False)

    # 3) Elimina filas completamente vacías
    df.dropna(how="all", inplace=True)
    # Elimina filas que repiten el header (p.ej. 'PRODUCT NUMBER')
    if "product_number" in df.columns:
        df = df[~df["product_number"].astype(str).str.lower().eq("product number")]

    # 4) Normaliza nombres: strip, lowercase, espacios → guiones bajos
    df.columns = [c.strip().lower().replace(" ", "_") for c in df.columns]

    # 5) Detecta y convierte dinámicamente columnas numéricas
    for col in df.columns:
        s = df[col].astype(str)
        # patrón: dígitos, opcional decimal, opcional guion final
        if s.str.match(r"^\s*\d+(?:\.\d+)?-?\s*$").all():
            neg = s.str.endswith("-")
            vals = s.str.replace(r"-$","",regex=True).astype(float)
            df[col] = vals.where(~neg, -vals)

    # 6) Agrega metadatos fijos al final
    df["plant_location"] = plant_location(path)
    df["date_inserted"]  = effective_date(path)
    df["source"]         = "pdf"

    # Reordena para que los metadatos queden al final
    cols = [c for c in df.columns if c not in ("plant_location","date_inserted","source")]
    return df[cols + ["plant_location","date_inserted","source"]]

# Ejecución desde terminal
if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Uso: python quick_statesville_multi.py <archivo.pdf>")
        sys.exit(1)

    pdf_path = sys.argv[1]
    df = read_file(pdf_path)

    print("\n--- TIPOS DEL DATAFRAME ---")
    print(df.dtypes, "\n")

    print("--- INFO DEL DATAFRAME FINAL ---")
    df.info()

    print("\n--- MUESTRA DE FILAS ---")
    print(df.head())
