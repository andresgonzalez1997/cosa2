from __future__ import annotations
"""
purina_file_horizontal.py – captura y limpieza de PDFs Statesville
=================================================================
* Recorta cabeceras y fragmentos
* Normaliza números
* Añade metadatos (planta, fecha)
Última modificación: 2025‑04‑18
"""
import datetime as _dt
import pathlib
import re
from typing import List, Optional

import pandas as pd
import tabula

# --------------------------------------------------------------------------- #
# 1. Columnas estándar
# --------------------------------------------------------------------------- #
COLUMN_NAMES: List[str] = [
    "product_number", "formula_code", "product_name", "product_form",
    "unit_weight", "pallet_quantity", "stocking_status", "min_order_quantity",
    "days_lead_time", "fob_or_dlv", "price_change", "list_price",
    "full_pallet_price", "half_load_full_pallet_price",
    "full_load_full_pallet_price", "full_load_best_price",
]

NUMERIC_COLS: List[str] = [
    "pallet_quantity", "min_order_quantity", "days_lead_time",
    "price_change", "list_price", "full_pallet_price",
    "half_load_full_pallet_price", "full_load_full_pallet_price",
    "full_load_best_price",
]

# --------------------------------------------------------------------------- #
# 2. Conversión numérica
# --------------------------------------------------------------------------- #
_NEG_RX, _NEG_TRAIL_RX = re.compile(r"\(([^)]+)\)$"), re.compile(r"^-?[\d,.]+-$")
_COMMA_RX = re.compile(r"[, ]")

def _to_float(val):
    if val is None or (isinstance(val, float) and pd.isna(val)):
        return None
    s = str(val).strip()
    sign = -1 if _NEG_RX.search(s) or _NEG_TRAIL_RX.match(s) else 1
    s = _COMMA_RX.sub("", s.strip("()‑"))
    try:
        return float(s) * sign
    except ValueError:
        return None

def _fix_numeric(df: pd.DataFrame) -> pd.DataFrame:
    for col in NUMERIC_COLS:
        if col in df.columns:
            df[col] = df[col].apply(_to_float).astype("float64")
    return df

# --------------------------------------------------------------------------- #
# 3. Metadatos
# --------------------------------------------------------------------------- #
DATE_RX  = re.compile(r"(\d{1,2}/\d{1,2}/\d{2,4})")
PLANT_RX = re.compile(r"\bPLANT:\s*([A-Za-z ]+)", re.I)

def _first_table(pdf, area):
    try:
        tbls = tabula.read_pdf(pdf, pages=1, lattice=True, guess=False,
                               area=area, pandas_options={"dtype": str, "header": None})
        return str(tbls[0]) if tbls else None
    except Exception:
        return None

def effective_date(pdf):
    text = _first_table(pdf, [50, 0, 200, 400])
    if not text:
        return None
    m = DATE_RX.search(text)
    if not m:
        return None
    for fmt in ("%m/%d/%Y", "%m/%d/%y"):
        try:
            return _dt.datetime.strptime(m.group(1), fmt).date().isoformat()
        except ValueError:
            continue
    return None

def plant_location(pdf):
    text = _first_table(pdf, [0, 400, 100, 800])
    if not text:
        return None
    m = PLANT_RX.search(text)
    return m.group(1).strip().title() if m else None

# --------------------------------------------------------------------------- #
# 4. Filas basura
# --------------------------------------------------------------------------- #
HEADER_TOKENS = ("PRODUCT NUMBER","PRODUCT DESC","PRICE CHANGE",
                 "PRICE IN US DOLLARS","MONTHLY","PAGE")
_PRICE_RE = re.compile("|".join(re.escape(t) for t in HEADER_TOKENS), re.I)

def _is_header_row(row: pd.Series) -> bool:
    first = str(row.iloc[0]).strip().upper()
    combined = " ".join(str(x) for x in row.tolist()).upper()

    # Cabeceras típicas
    if first.startswith("PRODUCT NUMBER") or first.startswith("PRICE CHANGE"):
        return True

    # Fragmentos, si la fila no tiene precios
    if "list_price" in row.index and pd.isna(row["list_price"]):
        if _PRICE_RE.search(combined):
            return True
    else:
        # Para tablas sin 'list_price', usa sólo el patrón de palabras
        if _PRICE_RE.search(combined):
            return True

    return False

# --------------------------------------------------------------------------- #
# 5. Lectura, estandarización y limpieza
# --------------------------------------------------------------------------- #
def _read_tables(pdf):
    return tabula.read_pdf(pdf, pages="all", lattice=True, guess=False,
                           pandas_options={"dtype": str, "header": None})

_COLUMN_MAP = {
    "PRODUCT NUMBER": "product_number",
    "FORMULA CODE":   "formula_code",
    "PRODUCT DESC.":  "product_name",
    "PRODUCT FORM":   "product_form",
    "UNIT  WEIGHT":   "unit_weight",
    "PALLET  QUANTITY": "pallet_quantity",
    "STOCKING  STATUS": "stocking_status",
    "MIN ORDER  QUANTITY": "min_order_quantity",
    "DAYS  LEAD  TIME": "days_lead_time",
    "FOB / DLV": "fob_or_dlv",
    "PRICE  CHANGE": "price_change",
    "LIST  PRICE": "list_price",
    "FULL  PALLET  PRICE": "full_pallet_price",
    "HALF  LOAD  FULL  PALLET  PRICE": "half_load_full_pallet_price",
    "FULL  LOAD  FULL  PALLET  PRICE": "full_load_full_pallet_price",
    "FULL  LOAD  BEST  PRICE": "full_load_best_price",
}

def _standardize_table(df: pd.DataFrame) -> pd.DataFrame:
    if df.empty:
        return df
    header = [str(c) if not pd.isna(c) else "" for c in df.iloc[0]]
    df.columns = [h.strip() or f"col_{i}" for i, h in enumerate(header)]
    df = df.iloc[1:].reset_index(drop=True)
    df.rename(columns=_COLUMN_MAP, inplace=True)
    return df[[c for c in COLUMN_NAMES if c in df.columns]]

def read_file(pdf_path) -> pd.DataFrame:
    pdf = str(pdf_path)
    tables = _read_tables(pdf)

    std_tables = [t for t in (_standardize_table(tbl) for tbl in tables) if not t.empty]

    data = pd.concat(std_tables, ignore_index=True) if std_tables else pd.DataFrame()
    data = data[~data.apply(_is_header_row, axis=1)].reset_index(drop=True)
    data.dropna(how="all", inplace=True)

    data["plant_location"] = plant_location(pdf)
    data["date_inserted"]  = effective_date(pdf)
    data["source"]         = "pdf"

    return _fix_numeric(data)[[*COLUMN_NAMES, "plant_location",
                               "date_inserted", "source"]]

